innodb 索引即数据
一.主键索引-聚簇索引（聚集索引）
1.设置了主键，将主键设置为聚集索引，使用B+树存储数据
节点存储主键的值及左右节点的地址，完整的数据存在叶子节点，并且叶子节点之间为双向链表保持有序
此特性可以做范围查询，比如查询 id>18的数据，找到了id=18的主键节点，io次数是树的深度，在叶子节点找到id=18
的完整数据，此时不需要返回根节点重新遍历B+树，只需要在叶子节点之间根据指向地址继续查找即可
2.未设置主键，但设置了没有空值的唯一索引，将此索引设为聚集索引
3.未设置主键，也没有唯一索引，innodb自动增加一个_rowid作为聚集索引

为什么不采用红黑树做索引的数据结构？？？
红黑树的机制保证的最大查找次数不超过最小次数的2倍，如果最小次数10次，那最大可能是20次
这会导致io不稳定，适合内存数据结构

二.辅助索引，主键索引之外的索引都叫辅助索引
比如除了聚集索引之外，在name字段上创建了辅助索引，检索name='李美丽'的数据
节点存储name值即左右节点的地址，叶子节点存储主键的值
根据name='李美丽'，遍历辅助索引b+数在叶子节点得到主键值，然后再遍历聚集索引树得到完整数据

为什么不在辅助索引的叶子节点直接存储完整数据呢？
  与主键索引存储重复造成磁盘空间浪费
为什么不在辅助索引的叶子节点存储完整数据的地址呢？
  因为b+树保持平衡的方式是（page页的）分裂和合并，这会导致数据的物理地址变化，所以存储主键值

三.创建索引的规则
要在where 条件里面建立索引
离散度公式：count(distinct(column_name)):count(*)。优先选择离散度高的字段创建索引

联合索引：节点存储联合索引字段的值，顺序与创建索引的字段顺序一致
  最左匹配原则
覆盖索引：
  explain sql语句，出现 Using index 就表示是覆盖索引
  select column_name 的字段存在索引中，不需要到主键索引树中拿叶子节点数据
  回表：辅助索引查找主键再扫描主键索引树的过程叫回表

索引条件下推：
  获取――存储引擎
  过滤、排序――server
  联合索引 姓+名  select * from user where last_name='王' and first_name like '哈哈%'


AVL树、B树、B+树 分别解决了什么问题
1.AVL解决了二叉树的平衡问题，即保证左右子树树高差不超过1，避免了线性表的产生
通过旋转的方式保持平衡，所以写操作比较慢，适合都多写少的场景
2.


mysql事务与锁机制
事务结束的时候持有的锁会自动释放

ACID:原子性、一致性、隔离性、持久性
原子性：
一致性：
隔离性：
持久性：redo-log+双写缓冲
（操作系统一页是4k，数据库一页16k,一页要写四次才可以写完，当写了一半系统崩掉了，就需要依靠双写缓冲里的备份恢复数据了）

innodb 解决了脏读、不可重复读、幻读！！！

解决幻读的方式：
  1.读数据前加锁，阻止其他事务进行操作――当前读 LBCC   for update
  2.生成一个请求时间点的一致性数据快照――快照读 MVCC  普通select


行锁：
  共享锁（share locks）――读锁 s锁
    在sql语句后面加上 lock in share mode  
  排他锁（exclusive locks）――写锁 x锁
    insert/delete/update 自动加上x锁
    手动 select for update

  意向锁
    先思考一个问题：如何判断是否存在已经给 一张表的某一行数据加了锁呢？
    1：全表扫描，如果扫描过程中加了锁会存在并发的问题
    2：意向锁，给某一行加锁前，先给表加上意向锁（不是真的锁，只是一个标志）

  释放锁：事务结束-回滚或提交

锁的作用是什么？
解决资源竞争（资源是行或者表）
锁到底锁住了什么？
行？列？表？――――锁住的是索引

1.没有索引为什么会锁表？
  不可能没有索引，会默认_rowid创建聚簇索引
  全表扫描会把隐藏的聚集索引全部锁住

2.唯一索引加锁为什么会阻塞主键索引加锁？
  innodb
  辅助索引需要 访问 主键索引

锁算法
记录锁（record locks）
间隙锁（gap locks）--左开右开
临键锁（next-key locks）--左开右闭（会退化到间隙锁或记录锁）

间隙锁阻止了插入，所以是临键锁解决了幻读的问题


客户端
  连接池：
    比如 Druid、springboot的Hikari
    缓存
    集群：基于主从复制实现读写分离
    分库分表：垂直分库-业务角度 客户表、放款表、风控表
              水平分表-数据 比如 每张客户表存25w条数据
服务端
  增加可用连接数：max_connections 最大连接数
  不活动连接回收：wait_timeout 默认8小时 28800s

优化层级：1.硬件、2.操作系统、数据库配置、3.架构层次（缓存）、表结构存储引擎、sql语句和索引优化

哪些语句慢？
――――server层
1.有一个参数叫慢查询日志，默认不开启
slow_query%,多长时间算慢  long_query_time
mysqldumpslow --help   
可以用mysqldumpslow 命令统计慢sql的信息
2.show profiles，默认不开启，查看sql 语句执行时间

show status like 'com_select' ――统计select语句执行多少次（数据库重启值会清空）
show processlist ――服务端运行的线程信息 kill pid

――――存储引擎层
当前存储引擎运行状态――show engine innodb

explain select 分析字段
explain format=json select 格式化
1.select语句id，有大有小，先执行id大的语句，（比如子查询先查询最内层的）
  id一样，从上往下依次执行
2.type
  system --> 
  const --> 
  eq_ref -->（唯一索引） 
  ref --> （普通索引）
  range(索引范围) --> 我们的目标至少到这里
  index（索引全扫描）--> 
  all（没有用到索引）
3.extra 
  覆盖索引 using index
  using index condition 索引下推
  using where 用不到索引，要到server过滤
  using filesort 没有用到索引字段排序
  using temperature 对非索引列进行 distinct 或 group by 

表结构
字段长度：选择可以正确存储数据的最小类型
性别 tinyint
邮政编码固定6位 用定长  char(6)
变长 varchar

不建议用外键、触发器、视图（降低可读性）
大文件存储

冗余字段
字段拆分：

双11 勾引客户转账到余额宝，支付使用内部账户快
双11 0：00只能查看当天的交易， 降级
预售分流

具体的sql语句优化
1.情况
  表结构
  数据量
  业务含义
2.慢的原因
3.对症下药
尽量用 join代替 in
  union 替代or
  union all >union